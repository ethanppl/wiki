"use strict";(self.webpackChunkmy_wiki=self.webpackChunkmy_wiki||[]).push([[4462],{814:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>h,contentTitle:()=>o,default:()=>d,frontMatter:()=>r,metadata:()=>s,toc:()=>l});var s=n(6092),i=n(4848),a=n(8453);const r={title:"How does multifactor authentication (MFA) work?",tags:[{label:"Auth",permalink:"auth"},{label:"Computers",permalink:"computers"}],toc_min_heading_level:2,toc_max_heading_level:3,authors:"ethan",image:"./assets/mfa-totp/mfa-totp-app.webp"},o="How does multifactor authentication (MFA) work?",h={image:n(2752).A,authorsImageUrls:[void 0]},l=[{value:"What is a &quot;factor&quot;?",id:"what-is-a-factor",level:2},{value:"Time-based one-time password (TOTP)",id:"time-based-one-time-password-totp",level:2},{value:"Explain like I am five",id:"explain-like-i-am-five",level:2},{value:"TOTP in detail",id:"totp-in-detail",level:2},{value:"Hash functions",id:"hash-functions",level:3},{value:"Unix time",id:"unix-time",level:3},{value:"Shared secret",id:"shared-secret",level:3},{value:"TOTP algorithm",id:"totp-algorithm",level:3},{value:"Resynchronization",id:"resynchronization",level:3},{value:"Security Considerations",id:"security-considerations",level:2},{value:"Implementation Details",id:"implementation-details",level:2},{value:"Setting up TOTP",id:"setting-up-totp",level:3},{value:"Recovery Codes",id:"recovery-codes",level:3},{value:"Authenticating TOTP",id:"authenticating-totp",level:3},{value:"Libraries and third party service",id:"libraries-and-third-party-service",level:3},{value:"Useful links",id:"useful-links",level:2}];function c(e){const t={a:"a",code:"code",h2:"h2",h3:"h3",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.p,{children:"What is that 6 digits number in the authenticator app? Why those numbers change\nevery 30 seconds? How are they generated? How does the server know that this is\nthe correct number? How does it work offline?"}),"\n",(0,i.jsx)(t.p,{children:"Also, why do we need to scan a QR code when setting it up? What does the QR code\ncontains? How secure is the whole system? What are the limitations? What to\nconsider if implementing a server to support this authentication method?"}),"\n",(0,i.jsxs)(t.p,{children:["We will start with a some simple intuitive explanation and slowly go into the\ntechnical details and algorithms. Hopefully you can answer all the above\nquestions after reading this. This is not a high level explanation of why it's\ngood to have MFA, or how to deploy it, there are\n",(0,i.jsx)(t.a,{href:"https://www.microsoft.com/en-us/security/blog/2020/01/15/how-to-implement-multi-factor-authentication/",children:"plenty"}),"\n",(0,i.jsx)(t.a,{href:"https://www.cyber.gov.au/resources-business-and-government/maintaining-devices-and-systems/system-hardening-and-administration/system-hardening/implementing-multi-factor-authentication",children:"of"}),"\n",(0,i.jsx)(t.a,{href:"https://www.okta.com/resources/whitepaper/8-steps-for-effectively-deploying-mfa/",children:"resources"}),"\n",(0,i.jsx)(t.a,{href:"https://auth0.com/blog/multifactor-authentication-mfa/",children:"explaining"})," that\nalready. This article focus on the details of the technology under the hood."]}),"\n",(0,i.jsx)(t.p,{children:"If you are ready, let's get started. First, we need to understand what is a\nfactor means in multifactor authentication."}),"\n",(0,i.jsx)(t.h2,{id:"what-is-a-factor",children:'What is a "factor"?'}),"\n",(0,i.jsx)(t.p,{children:"A factor is like a key for a different kind of locks. Imagine a door has only 1\nlock, then everyone who has the key to that lock can open the door. Multifactor\nis like having multiple locks on the doors that require different keys. Even if\nyou lost 1 key accidentally, the door is still locked."}),"\n",(0,i.jsx)(t.p,{children:"In digital systems, usually the lock is the username and password. If this is\nthe only factor, if someone can steal or guess your password, then your account\nis compromised. If there is an extra factor, usually in a different format, like\nauthenticator app or a separate physical security key, then your account will be\nsecure even if your password is leaked."}),"\n",(0,i.jsxs)(t.p,{children:["In ",(0,i.jsx)(t.a,{href:"https://arxiv.org/abs/2305.00945",children:"a study conducted by Microsoft in 2023"}),",\nMFA reduces the risk of being compromised by 99.22%! Also, dedicated\nauthenticator app like Microsoft Authenticator outperform SMS-based\nauthentication."]}),"\n",(0,i.jsx)(t.h2,{id:"time-based-one-time-password-totp",children:"Time-based one-time password (TOTP)"}),"\n",(0,i.jsx)(t.p,{children:"This article will focus on explaining these authenticator apps, the one you see\n6 digits number changing every 30 seconds. It is called time-based one-time\npassword, TOTP in short. We will know how does the TOTP algorithm generate that\n6 digits number, why does it change every 30 seconds, how does the server know\nthe same 6 digits number even if the authenticator app is offline."}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{alt:"A typical authenticator app",src:n(3467).A+"",width:"706",height:"324"})}),"\n",(0,i.jsxs)(t.p,{children:["The formal document that defines how TOTP should work is defined in\n",(0,i.jsx)(t.a,{href:"https://datatracker.ietf.org/doc/html/rfc6238",children:"RFC 6238"}),". TOTP is a way to\ngenerates a user-friendly value based on the current time, called the one time\npassword (OTP), to authenticate the user. The one time password is used once\nonly and cannot be reused. But before we go deep into the terminologies and how\nall these work, let's look at a simpler, imaginative scenario to understand the\nidea behind TOTP. Let's imagine we need to secure a phone call."]}),"\n",(0,i.jsx)(t.h2,{id:"explain-like-i-am-five",children:"Explain like I am five"}),"\n",(0,i.jsx)(t.p,{children:'Imagine Alice and Bob phone call each other to share updates and secrets, but\nthey are often scared that the phone is not picked up by one of them but\nMallory, so they both come up with a secret phrase, "chipmunk" and "chinchilla".\nEvery time before the phone call starts, Alice and Bob need to tell their secret\nphrase. Only if both sides are correct, they start talking. It works well until\none time Bob realize Mallory is listening from behind and hear the secret phrase\n"chinchilla", what can they do?'}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{alt:"Phone call with secret phrase",src:n(2355).A+"",width:"850",height:"346"})}),"\n",(0,i.jsx)(t.p,{children:"Turns out, there is a special species of magic parrot. The magic parrots are\nalways twin. At any given time, you can ask the magic parrot to say a random\nword. The two magic parrots will say the same word even if they are physical\nseparated far away."}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{alt:"Phone call secured by magic parrot twins",src:n(9813).A+"",width:"1282",height:"532"})}),"\n",(0,i.jsx)(t.p,{children:'Now, as long as Alice and Bob keep their magic parrot secure to them, they are\nsafe. Even if Mallory knows the secret phrase "chipmunk" or "chinchilla", she\ncannot impersonate Alice and Bob because she doesn\'t have that specific magic\nparrot. She cannot reuse "goose" either because this word is randomly generated\nby the magic parrot and used once only.'}),"\n",(0,i.jsx)(t.p,{children:'If you understand why the magic parrot makes it more secure, then you know why\nTOTP makes authentication systems more secure. The magic parrot is the second\nfactor. In TOTP, "chipmunk" or "chinchilla", is your username and password. And\n"goose" is the TOTP, the generated one-time password. The magic parrot is the\nTOTP algorithm. It can generate a random value at any given time.'}),"\n",(0,i.jsx)(t.p,{children:"In the real world, there is no magic parrot twins that work like this, but we\ncan create something digitally that works in the same way."}),"\n",(0,i.jsx)(t.h2,{id:"totp-in-detail",children:"TOTP in detail"}),"\n",(0,i.jsx)(t.p,{children:"This is the typical flow of an authentication with TOTP."}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{alt:"The typical flow of TOTP authentication",src:n(9078).A+"",width:"1262",height:"766"})}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsxs)(t.li,{children:["The user first login with username and password, or any other authentication\nmethods like\n",(0,i.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Single_sign-on",children:"single signed-on (SSO)"})]}),"\n",(0,i.jsx)(t.li,{children:"The server verifies the identity and confirm that the user has enabled\nmultifactor authentication, so the server requests the user to provide the\nTOTP"}),"\n",(0,i.jsx)(t.li,{children:"The user get the TOTP from where it is stored, e.g. authenticator app or\npassword managers, and submits it"}),"\n",(0,i.jsx)(t.li,{children:"The server also generates the TOTP from its end and compare the two is the\nsame"}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"We are going to focus on step 3 and 4, particularly how the user and the server\nare able to generate the TOTP without communicating at that point."}),"\n",(0,i.jsx)(t.p,{children:"To understand how TOTP is generated and why it is secure, we need to know three\nbasic ingredients. A hash function, the Unix timestamp and a shared secret\nbetween the server and the user."}),"\n",(0,i.jsx)(t.h3,{id:"hash-functions",children:"Hash functions"}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Hash_function",children:"Hash functions"})," in short are any\none-way function that can map any data into another fixed size value. It has a\nfew key properties that you need to keep in mind:"]}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsx)(t.li,{children:"Given the same data, it will always generate the same hash"}),"\n",(0,i.jsx)(t.li,{children:"Given a different set of data, it will always generate a different hash"}),"\n",(0,i.jsx)(t.li,{children:"When given a hash, it\u2019s impossible to guess or know what is the data that\ngenerated this hash"}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["Based on the first two properties, hash functions should never collide. The\nnumber of bits in a hash is large, usually 256 or above. At that scale, a\ncollision is extremely unlikely. If you don't believe this work you may watch\n",(0,i.jsx)(t.a,{href:"https://youtu.be/S9JGmA5_unY",children:"this video from 3blue1brown on how secure is 256 bits"}),"\nor read about the\n",(0,i.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Birthday_problem",children:"birthday problem"}),"."]}),"\n",(0,i.jsx)(t.p,{children:"Hash functions should also be one-way. One intuitive way to understand one-way\nfunction is multiplication and factoring. Multiplying two numbers together is\nkind of like \"one-way\". It is relatively easy to calculate 89 \xd7 67 = 5963, I\nbelieve you can do it with a pen and paper in a minute. But if only 5963 is\ngiven, and you were asked to find out which two numbers multiply to 5963, it's\nway harder. Hope this can convince you there are such one-way, irreversible\nmathematical operations exist. They aren't absolutely impossible to reverse,\njust way harder."}),"\n",(0,i.jsx)(t.h3,{id:"unix-time",children:"Unix time"}),"\n",(0,i.jsx)(t.p,{children:"The second basics we need to understand is there is a globally universal\ntimestamp. Even though your computer might be disconnected from the internet, as\nlong as it has battery and the clock is correct, all computers should share the\nsame timestamp."}),"\n",(0,i.jsxs)(t.p,{children:["In computers, there is a standard way to define the time, which is the\n",(0,i.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Unix_time",children:"Unix time"}),". That is the number of\nseconds since 00:00:00 UTC on 1 January 1970. There are some quirks and\nexceptions (e.g. leap seconds), but all computers should be able to calculate\nthe same Unix time at any given moment."]}),"\n",(0,i.jsx)(t.p,{children:"The timestamp is the important let the server and user generates the TOTP code\nseparately without communication to each other."}),"\n",(0,i.jsx)(t.h3,{id:"shared-secret",children:"Shared secret"}),"\n",(0,i.jsx)(t.p,{children:"The last but not least is there is a shared secret only know by the server and\nthe user. When you use the authenticator app to scan a QR code to register the\nmultifactor authentication, that is when the shared secret is exchanged."}),"\n",(0,i.jsxs)(t.p,{children:["The shared secret should not be revealed after the initial exchange. The shared\nsecret should be random, unique for each user, and has a high\n",(0,i.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Entropy_(information_theory)",children:"entropy"})," that\nit's not possible to be guessed or brute forced."]}),"\n",(0,i.jsx)(t.p,{children:"In the authenticator app example, the authenticator app gets the shared secret\nfrom the QR code and stores it, which usually is just random bytes of human\nunreadable data. The server also stores a copy of the secret uniquely linked to\nthis user."}),"\n",(0,i.jsx)(t.p,{children:"Now we go to the actual algorithm."}),"\n",(0,i.jsx)(t.h3,{id:"totp-algorithm",children:"TOTP algorithm"}),"\n",(0,i.jsx)(t.p,{children:"The TOTP algorithm works like this:"}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsx)(t.li,{children:"Using a hash functions to hash the shared secret recursively"}),"\n",(0,i.jsx)(t.li,{children:"Using the current timestamp to determine how many times to hash"}),"\n",(0,i.jsx)(t.li,{children:"Calculate the modulus of the hash based on the size of the TOTP, this gives a\nhuman-readable 6 digits number"}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["You can read more of the detail algorithm in\n",(0,i.jsx)(t.a,{href:"https://datatracker.ietf.org/doc/html/rfc6238#section-4",children:"section 4"})," of the RFC,\nwhich is based on top of the HMAC-based One-Time Password (HOTP) algorithm\ndefined in ",(0,i.jsx)(t.a,{href:"https://datatracker.ietf.org/doc/html/rfc4226",children:"RFC 4226"}),"."]}),"\n",(0,i.jsxs)(t.p,{children:["The hash function used as specified in the RFC 6238 should be\n",(0,i.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Secure_Hash_Algorithms",children:"SHA-256 or SHA-512"}),". This\nis also agreed and stored in the authenticator app when scanning the QR code.\nBecause hash functions generate different value given different input, without\nknowing the shared secret, it is impossible to generate the same number. This is\nthe reason why at any given time, there is only 1 valid number for this user,\nand the server is able to verify that. Also, because hash functions are one-way,\neven if the TOTP code is exposed, it is not possible to guess the shared secret\nunless brute force."]}),"\n",(0,i.jsx)(t.p,{children:"In this algorithm, the timestamp used is not the exact Unix time, otherwise the\n6 digits number will change every second. It will be impractical to ask a user\nto enter 6 digits and submit within a second. The longer the time before\nchanging the number, the better the usability for the users, because it's less\nlikely the number changed midway when the user is inputting it. But the longer\nit is, the less secure it is, because there is a larger window that the TOTP is\nexposed. It's always a trade-off. The RFC 6238 recommends a time step of 30\nseconds, which means the number only change every 30 seconds. If you open your\nauthenticator app now, and reference a clock, you should see the number\nrefreshes at the 00 or 30 seconds mark in a minute, unless it is not using 30\nseconds as the time step."}),"\n",(0,i.jsx)(t.p,{children:"As you can see, even if the authenticator app is offline and there is no\ncommunication between your phone and the server, both of them can generate the\nsame 6 digits number."}),"\n",(0,i.jsx)(t.h3,{id:"resynchronization",children:"Resynchronization"}),"\n",(0,i.jsx)(t.p,{children:"It is possible that there are delays in the network connection, or the clock on\nthe user device is delayed, or the user input the number too slow. As such, the\nRFC recommends the validation server support resynchronization. For example, the\ncurrent and the last 2 TOTP generated are all valid. The number of steps\nbackward to consider valid is again a trade-off between usability and security.\nThe server may optionally record the drift that the user clock has and adjust\nfor that in future validations."}),"\n",(0,i.jsx)(t.h2,{id:"security-considerations",children:"Security Considerations"}),"\n",(0,i.jsx)(t.p,{children:"There are various best practices for TOTP to be secure."}),"\n",(0,i.jsxs)(t.p,{children:["First, the user must keep their TOTP secret a secret. It is assumed that the\nsecret is securely stored in authenticator app or password manager. That should\nnot be accessible over the internet. Therefore,\n",(0,i.jsx)(t.a,{href:"https://news.ycombinator.com/item?id=35708869",children:"it is controversial"})," when Google\nAuthenticator supports syncing and backing up secrets to Google."]}),"\n",(0,i.jsx)(t.p,{children:"All communications between the user and the server should be done over a secure\nchannel, e.g. HTTPS. It is true that revealing the TOTP will not leak the shared\nsecret, but it's best to not leak it at all. The initialization phase must be\ncommunicated over secure channel. If the initial setup QR code is leaked, the\nattacker has access to the shared secret and the attacker can always generate\nthe TOTP."}),"\n",(0,i.jsx)(t.p,{children:"The TOTP code should also be used once only, as specified in the name, one-time\npassword. For example, if the user login to the account using a TOTP code, that\ncode should not be valid any more. This is to prevent an attacker that has\naccess to the newly sent TOTP code from reusing that code to gain access. The\nuser must wait for 30 seconds for the next code to be generated to log in."}),"\n",(0,i.jsx)(t.p,{children:"Given all these practices, the best possible attack against this system should\njust be brute forcing to guess the shared secret. And as mentioned, the shared\nsecret should be long enough that it's not possible to guess and brute force in\nreasonable timeframe."}),"\n",(0,i.jsx)(t.p,{children:"TOTP is still vulnerable to phishing attacks. Say the user is logging into a\nfake authentication website, or willing transferring the generated TOTP to\nattackers. Attackers can then proxy or input the TOTP code in real time to gain\naccess to the system."}),"\n",(0,i.jsx)(t.h2,{id:"implementation-details",children:"Implementation Details"}),"\n",(0,i.jsx)(t.p,{children:"There are two things to set up for the server. Initializing the TOTP and\nauthentication the TOTP."}),"\n",(0,i.jsx)(t.h3,{id:"setting-up-totp",children:"Setting up TOTP"}),"\n",(0,i.jsxs)(t.p,{children:["When a user set up TOTP, the server usually provides a QR code. It is the\neasiest way and foolproof way to exchange the shared secret. The user can use a\nseparate device to get the secret without the need to copy and paste. Most\nphones have a camera nowadays, and password manager browser extensions (e.g.\n",(0,i.jsx)(t.a,{href:"https://support.1password.com/one-time-passwords/",children:"1Password"}),") can scan QR\ncodes as well. QR codes have error correction by default and since users do not\nneed to type in the unreadable secret, making it less likely to make mistakes."]}),"\n",(0,i.jsx)(t.p,{children:"The QR code is usually a URL in the format of"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"otpauth://totp/<issuer>:<account>?secret=<RandomBytesOfData>\n"})}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"otpauth"})," is the scheme"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"totp"})," is the type of OTP that we are using"]}),"\n",(0,i.jsx)(t.li,{children:"The issuer is usually the organization, e.g. Google, Microsoft"}),"\n",(0,i.jsx)(t.li,{children:"The account is usually your username or email"}),"\n",(0,i.jsx)(t.li,{children:"The secret must be present in the parameters, usually a long string"}),"\n",(0,i.jsxs)(t.li,{children:["There are optional parameters like ",(0,i.jsx)(t.code,{children:"algorithm"})," for the hash function used,\n",(0,i.jsx)(t.code,{children:"period"})," which defaults to 30 as mentioned above, and ",(0,i.jsx)(t.code,{children:"digits"})," for the number\nof digits in the OTP code, which is usually 6"]}),"\n",(0,i.jsxs)(t.li,{children:["You can read more about the URL format of TOTP in\n",(0,i.jsx)(t.a,{href:"https://docs.yubico.com/yesdk/users-manual/application-oath/uri-string-format.html",children:"this page"})]}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"Before the user account has MFA enabled, the server should ask for a TOTP code\nto verify that the user correctly saved the shared secret. Only if that code is\nvalid, MFA is successfully enabled. The server needs to handle the state where\nthe shared secret is generated and stored, but the MFA is not enabled yet."}),"\n",(0,i.jsx)(t.h3,{id:"recovery-codes",children:"Recovery Codes"}),"\n",(0,i.jsx)(t.p,{children:"In practical use, it is possible that users lose access to their phone or\nwherever the TOTP codes are generated. It is a challenging aspect because the\neasier it is for a user to recover the account after failed to log in with MFA\nmeans the easier it is for attacker to use the same method to compromise the\naccount."}),"\n",(0,i.jsx)(t.p,{children:"One way to recover the account is the server provides some single-use recovery\ncodes, usually some longer random strings. They are usually shown to the user\nonce after the MFA is first successfully enabled. Each recovery codes should\nonly be used once only, same as how TOTP codes can only be used once to prevent\nreplay by an attacker."}),"\n",(0,i.jsx)(t.p,{children:"During authentication, the system should allow the user to input recovery codes\nand if matches, the user is logged in but that recovery code is invalidated. The\nusers are responsible for keeping the recovery codes secure and use it only when\nTOTP codes are not available."}),"\n",(0,i.jsx)(t.p,{children:"Alternative recovery methods includes"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Mailing a one-use recovery codes to the user"}),"\n",(0,i.jsx)(t.li,{children:"Require the user to contacting the support team to verify the identity before\nresetting the MFA"}),"\n",(0,i.jsx)(t.li,{children:"Require users to set up multiple MFA to limit the likelihood of losing access\nto all methods at once"}),"\n"]}),"\n",(0,i.jsx)(t.h3,{id:"authenticating-totp",children:"Authenticating TOTP"}),"\n",(0,i.jsx)(t.p,{children:"Before supporting MFA, the login endpoint of the server will either return login\nsuccess or login failed. With TOTP supported, the server has a third response,\nindicating the credentials are valid but a TOTP code is required because MFA is\nenabled."}),"\n",(0,i.jsx)(t.p,{children:"In this response, the server should also return a unique token, (e.g. a JWT\ntoken) to the frontend. This token will expire in a short period of time, like 5\nminutes. It has to be submitted to a separate TOTP validation endpoint together\nto signal that this particular user already passed the username & password\nvalidation in a previous step. The server use this token to determine which user\nis trying to log in and which TOTP shared secret to use to validate the TOTP\ncode submitted. Without this step, a user can just log in with a TOTP code in\nthe TOTP endpoint without even having the password validation step, which means\nthe system is back to single factor authentication. Another option is the\nfrontend stores the previously inputted username and password, and submit that\nto the server alongside the TOTP code."}),"\n",(0,i.jsx)(t.h3,{id:"libraries-and-third-party-service",children:"Libraries and third party service"}),"\n",(0,i.jsxs)(t.p,{children:["Knowing how the algorithm works behind the scenes is great, but you should never\nimplement the algorithms yourself. Use a library instead. For example,\n",(0,i.jsx)(t.a,{href:"https://www.npmjs.com/package/otpauth",children:(0,i.jsx)(t.code,{children:"otpauth"})})," in the NPM registry for Node,\nDeno, Bun runtime in JavaScript."]}),"\n",(0,i.jsx)(t.p,{children:"There are also third party services that provide authentication or MFA as a\nservice. It is good for applications that do not have resources to implement\ntheir own authentication system, but also require careful consideration for the\nsecurity, integrity and availability of the third party service."}),"\n",(0,i.jsx)(t.h2,{id:"useful-links",children:"Useful links"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.a,{href:"https://cheatsheetseries.owasp.org/cheatsheets/Multifactor_Authentication_Cheat_Sheet.html",children:"OWASP Multifactor Authentication Cheat Sheet"})}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.a,{href:"https://datatracker.ietf.org/doc/html/rfc6238",children:"RFC 6238 TOTP: Time-Based One-Time Password Algorithm"})}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Multi-factor_authentication",children:"Wikipedia: Multi-factor Authentication"})}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Time-based_one-time_password",children:"Wikipedia: Time-based One-time Password"})}),"\n"]})]})}function d(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},2752:(e,t,n)=>{n.d(t,{A:()=>s});const s=n.p+"assets/images/mfa-totp-app-92d78cd6ea842942be4153d5f887cdf4.webp"},3467:(e,t,n)=>{n.d(t,{A:()=>s});const s=n.p+"assets/images/mfa-totp-app-92d78cd6ea842942be4153d5f887cdf4.webp"},9813:(e,t,n)=>{n.d(t,{A:()=>s});const s=n.p+"assets/images/phone-with-parrot-6503e7561bf57e58f830772debda7e7c.webp"},2355:(e,t,n)=>{n.d(t,{A:()=>s});const s=n.p+"assets/images/phone-5801a5ec8d9102fa14ee7f9993bdd901.webp"},9078:(e,t,n)=>{n.d(t,{A:()=>s});const s=n.p+"assets/images/totp-sequence-f963aee0e7459a8de39f8cfe67a239a1.webp"},8453:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>o});var s=n(6540);const i={},a=s.createContext(i);function r(e){const t=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),s.createElement(a.Provider,{value:t},e.children)}},6092:e=>{e.exports=JSON.parse('{"permalink":"/blog/2024/12/28/mfa-totp","source":"@site/blog/2024-12-28-mfa-totp.md","title":"How does multifactor authentication (MFA) work?","description":"What is that 6 digits number in the authenticator app? Why those numbers change","date":"2024-12-28T00:00:00.000Z","tags":[{"inline":true,"label":"Auth","permalink":"/blog/tags/auth"},{"inline":true,"label":"Computers","permalink":"/blog/tags/computers"}],"readingTime":14.91,"hasTruncateMarker":true,"authors":[{"name":"Ethan Pang","url":"https://github.com/ethanppl","imageURL":"https://github.com/ethanppl.png","key":"ethan","page":null}],"frontMatter":{"title":"How does multifactor authentication (MFA) work?","tags":[{"label":"Auth","permalink":"auth"},{"label":"Computers","permalink":"computers"}],"toc_min_heading_level":2,"toc_max_heading_level":3,"authors":"ethan","image":"./assets/mfa-totp/mfa-totp-app.webp"},"unlisted":false,"nextItem":{"title":"How I use keyd to remap my keyboard in Ubuntu 22.04 with Wayland","permalink":"/blog/2024/09/08/keyd"}}')}}]);