"use strict";(self.webpackChunkmy_wiki=self.webpackChunkmy_wiki||[]).push([[1795],{3428:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>r,toc:()=>d});var r=t(190),i=t(4848),s=t(8453);const a={title:"Reimplement all JavaScript Array Functions with while loops only",tags:[{label:"Computers",permalink:"computers"},{label:"JavaScript",permalink:"javascript"}],toc_min_heading_level:2,toc_max_heading_level:3,authors:"ethan"},o=void 0,l={authorsImageUrls:[void 0]},d=[{value:"What I learned",id:"what-i-learned",level:2},{value:"Sparse Arrays",id:"sparse-arrays",level:3},{value:"Arrays are Objects",id:"arrays-are-objects",level:3},{value:"Copy of a Reference",id:"copy-of-a-reference",level:3},{value:"Iterator and Generator",id:"iterator-and-generator",level:3},{value:"Using <code>.call()</code>",id:"using-call",level:3},{value:"Equality",id:"equality",level:3},{value:"Negative Indexes",id:"negative-indexes",level:3},{value:"Locales",id:"locales",level:3},{value:"Less known functions",id:"less-known-functions",level:3},{value:"<code>.copyWithin()</code>",id:"copywithin",level:4},{value:"<code>.splice()</code>",id:"splice",level:4},{value:"<code>.shift()</code> and <code>.unshift()</code>",id:"shift-and-unshift",level:4},{value:"<code>.toReversed()</code>, <code>.toSorted()</code> and <code>.toSpliced()</code>",id:"toreversed-tosorted-and-tospliced",level:4},{value:"<code>.with()</code>",id:"with",level:4},{value:"Implementation Considerations",id:"implementation-considerations",level:2},{value:"The setup",id:"the-setup",level:3},{value:"Similar functions",id:"similar-functions",level:3},{value:"<code>.flat()</code>",id:"flat",level:3},{value:"<code>.sort()</code>",id:"sort",level:3},{value:"Final thoughts",id:"final-thoughts",level:2},{value:"References",id:"references",level:2},{value:"Docs",id:"docs",level:3},{value:"Time complexity of all Array functions",id:"time-complexity-of-all-array-functions",level:3}];function c(e){const n={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.p,{children:["Last month, out of curiosity, I reimplemented all 38 JavaScript Array functions\n(e.g. ",(0,i.jsx)(n.code,{children:".forEach()"}),", ",(0,i.jsx)(n.code,{children:".map()"}),", ",(0,i.jsx)(n.code,{children:".sort()"}),", etc.) with while loops only. As always,\nI learned something as I work on the all the functions. Some features, edge\ncases, considerations that I previously do not know about JavaScript."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"/blog/2025/02/23/js-array#sparse-arrays",children:"There are sparse arrays and the pain of handling them"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"/blog/2025/02/23/js-array#arrays-are-objects",children:"Arrays are objects and its implications"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"/blog/2025/02/23/js-array#copy-of-a-reference",children:"What copy of a reference in JavaScript actually means"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"/blog/2025/02/23/js-array#iterator-and-generator",children:"What are iterators and generators"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"/blog/2025/02/23/js-array#equality",children:"Different kinds of equality in JavaScript"})}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["Other than that, there are some less-known functions that I discovered, at least\nI have not used them before until now, like ",(0,i.jsx)(n.code,{children:".copyWithin()"}),", ",(0,i.jsx)(n.code,{children:".splice()"})," and\n",(0,i.jsx)(n.code,{children:".with()"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["To be honest, most of the implementation is tedious and repetitive. A lot of\neffort goes into handling edge cases, which are the interesting things I\nlearned. The implementation is not as interesting compare to random things I\nlearned, so I will focus on sharing the lessons first. But if you really want\nto, you can skip to the\n",(0,i.jsx)(n.a,{href:"/blog/2025/02/23/js-array#implementation-considerations",children:"implementation considerations"}),"\nwhere I explained the setup, how some functions are implemented, especially some\ninteresting one like ",(0,i.jsx)(n.code,{children:".flat()"})," and ",(0,i.jsx)(n.code,{children:".sort()"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["The full code is available in ",(0,i.jsx)(n.a,{href:"https://github.com/ethanppl/js-array",children:"this repo"}),"."]}),"\n",(0,i.jsx)(n.h2,{id:"what-i-learned",children:"What I learned"}),"\n",(0,i.jsx)(n.h3,{id:"sparse-arrays",children:"Sparse Arrays"}),"\n",(0,i.jsxs)(n.p,{children:["The first thing I discovered, and the major source of pain in this experiment is\nsparse arrays. This means an array can have empty slots in between. Empty items\nare different from ",(0,i.jsx)(n.code,{children:"undefined"})," or ",(0,i.jsx)(n.code,{children:"null"}),". ",(0,i.jsx)(n.code,{children:"undefined"})," in an array is not empty\nitems. Empty slots are just empty. You can define sparse arrays like this:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"let a = [1, , 3];\nconsole.log(a);\n// [1, <empty>, 3]\n"})}),"\n",(0,i.jsx)(n.p,{children:"Or if you set the length of an array that is larger than its original length,\nthe new items are all empty."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"let a = [1];\na.length = 2;\nconsole.log(a);\n// [1, <empty>]\n"})}),"\n",(0,i.jsxs)(n.p,{children:["But if you access an empty item with the square bracket, it will return\n",(0,i.jsx)(n.code,{children:"undefined"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"let a = [1, , undefined];\nconsole.log(a[0]); // 1\nconsole.log(a[1]); // undefined\nconsole.log(a[2]); // undefined\n"})}),"\n",(0,i.jsxs)(n.p,{children:["So, the only way to know if an index is an empty slot, you use the ",(0,i.jsx)(n.code,{children:"in"}),"\noperator. If it returns false, then it is empty."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"let a = [1, , undefined];\nconsole.log(0 in a); // true\nconsole.log(1 in a); // false\nconsole.log(2 in a); // true\n"})}),"\n",(0,i.jsx)(n.p,{children:'To make an item empty, you cannot reassign "an empty value". You have to delete\nit from the array.'}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"let a = [1];\nconsole.log(a); // [1]\n\ndelete a[1];\nconsole.log(a); // [<empty>]\n"})}),"\n",(0,i.jsxs)(n.p,{children:["There are many more tricky things that comes with sparse arrays. For example,\nmost of the functions that take a callback like ",(0,i.jsx)(n.code,{children:".forEach()"}),", ",(0,i.jsx)(n.code,{children:".filter()"}),", and\n",(0,i.jsx)(n.code,{children:".reduce()"})," will skip empty items in the array. But despite it skips invoking\nthe callback, functions like ",(0,i.jsx)(n.code,{children:".map"}),", ",(0,i.jsx)(n.code,{children:".sort()"})," and ",(0,i.jsx)(n.code,{children:".reverse()"})," will preserve\nthe empty items in their output."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"const out = [1, , 3].map((e) => {\n  console.log(e);\n  return e ** e;\n});\nconsole.log(out);\n// 1\n// 3\n// [1, <empty>, 27]\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Functions like ",(0,i.jsx)(n.code,{children:".at()"})," on the other hand treat empty as ",(0,i.jsx)(n.code,{children:"undefined"}),". And newer\nfunctions that creates a copy of the original array, like ",(0,i.jsx)(n.code,{children:".toSorted()"})," and\n",(0,i.jsx)(n.code,{children:".toReversed()"}),", converts empty items to ",(0,i.jsx)(n.code,{children:"undefined"}),". Yes, it is pretty\ninconsistent."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"console.log([1, , 3].at(1));\n// undefined\n\nconsole.log([1, , 3].toReversed());\n// [3, undefined, 1]\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Also, ",(0,i.jsx)(n.code,{children:".sort()"})," takes a compare function to sort the elements. But empty items\nor ",(0,i.jsx)(n.code,{children:"undefined"})," are not invoked. All undefined and empty items are sorted to the\nend of the array, with ",(0,i.jsx)(n.code,{children:"undefined"})," comes first and then empty items."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"console.log([1, , 3, undefined, 2].sort());\n// [1, 2, 3, undefined, <empty>]\n"})}),"\n",(0,i.jsxs)(n.p,{children:["I did not know that arrays can have empty slots that is different from\n",(0,i.jsx)(n.code,{children:"undefined"}),". I thought ",(0,i.jsx)(n.code,{children:"undefined"})," means empty previously. I cannot think of a\nway that empty arrays are useful, maybe except for a potential marginal gain in\nmemory. Anything sparse arrays is useful for can be replaced by having\n",(0,i.jsx)(n.code,{children:"undefined"})," as the value. In addition, ",(0,i.jsx)(n.code,{children:"delete"})," and ",(0,i.jsx)(n.code,{children:"in"})," operation is not what\ndevelopers are used to when dealing with arrays. I do not think using sparse\narrays is a good practice."]}),"\n",(0,i.jsx)(n.h3,{id:"arrays-are-objects",children:"Arrays are Objects"}),"\n",(0,i.jsxs)(n.p,{children:["The reason why you can use ",(0,i.jsx)(n.code,{children:"delete"})," and ",(0,i.jsx)(n.code,{children:"in"})," to check whether an item is empty\nin an array, is because arrays are just objects. The index and value in an array\nis a key value pair. The array object implements some helper that comes with\nthis object to support the array functionality. And in fact, functions, sets, or\nstrings are also objects. They can inherit methods and properties."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"let a = [1, 2, 3];\nconsole.log(typeof a);\n// 'object'\n\nlet f = () => {};\nconsole.log(typeof f);\n// 'object'\n"})}),"\n",(0,i.jsx)(n.p,{children:"Therefore, when the length of the array is modified to be larger than original,\nthe key does not exist yet, hence the value is empty and the array is sparse. On\nthe other hand, when the length is shortened, the array object automatically\nclean up keys that are equal or larger than the length."}),"\n",(0,i.jsx)(n.p,{children:"Some consequences of Array being an object are the time complexity of these\nfunctions. For example, accessing any value of an array by index is O(1) because\nit is just a key value store underlying. This is different from lists in some\nlanguages that are linked lists under the hood, linked list usually requires\ntraversing the list from the start to access an item by index."}),"\n",(0,i.jsxs)(n.p,{children:["Another interesting consequences of time complexity is ",(0,i.jsx)(n.code,{children:".pop()"})," is O(1) while\n",(0,i.jsx)(n.code,{children:".shift()"})," is O(n). ",(0,i.jsx)(n.code,{children:".pop()"})," removes the last item in the array, and ",(0,i.jsx)(n.code,{children:".shift()"}),"\nremoves the first item in the array. ",(0,i.jsx)(n.code,{children:".pop()"})," is O(1) because it only needs to\nremove the last item, and the length of the array is decremented by 1.\n",(0,i.jsx)(n.code,{children:".shift()"})," is O(n) because it needs to remove the first item, and all the other\nitems need to be shifted to one index earlier."]}),"\n",(0,i.jsx)(n.h3,{id:"copy-of-a-reference",children:"Copy of a Reference"}),"\n",(0,i.jsx)(n.p,{children:"In JavaScript, objects are neither pass by value nor pass by reference, it is\ncalled copy of a reference. I knew there is something different but never able\nto remember it until now."}),"\n",(0,i.jsx)(n.p,{children:"First, in language with pointer, like c++, pass by value means the variable is\ncopied to another place in the memory. Modifying it in the function does not\nchange the original copy of the variable that is passed in. On the other hand,\npass by reference means the variable is not copied, but the reference to the\nvariable is passed in. Modifying it in the function will change the original\nvariable outside the scope of the function."}),"\n",(0,i.jsx)(n.p,{children:"For JavaScript, it is a bit different. It is called copy of a reference. Kind of\nlike a mixture of the two. When you pass an object to a function, you are\npassing a copy of the reference to the object. This means if you change the\nproperties of the object in the function, it will also change the object outside\nthe function. But if you reassign the object to a new object, it will not change\nthe object outside the function."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"let a = [1, 2, 3];\n\nconsole.log(a); // [1, 2, 3]\n\nlet foo = (arr) => {\n  arr[0] = 4;\n  console.log(arr); // [4, 2, 3]\n\n  arr = [5, 6, 7];\n  console.log(arr); // [5, 6, 7]\n};\n\nfoo(a);\n\nconsole.log(a); // [4, 2, 3]\n"})}),"\n",(0,i.jsxs)(n.p,{children:["I knew this before, but now I finally can remember it. This is important because\nsome functions like ",(0,i.jsx)(n.code,{children:".map()"})," and ",(0,i.jsx)(n.code,{children:".filter()"})," will return a new array and do not\nmodify the original array. But some functions like ",(0,i.jsx)(n.code,{children:".sort()"})," and ",(0,i.jsx)(n.code,{children:".reverse()"}),"\nmodify the original array."]}),"\n",(0,i.jsx)(n.h3,{id:"iterator-and-generator",children:"Iterator and Generator"}),"\n",(0,i.jsxs)(n.p,{children:["I learned about iterators and generators when I have to implement ",(0,i.jsx)(n.code,{children:".entries()"}),",\n",(0,i.jsx)(n.code,{children:".keys()"}),", and ",(0,i.jsx)(n.code,{children:".values()"}),". I have never used them, but now I learned what they\nare, what iterators and generators mean."]}),"\n",(0,i.jsxs)(n.p,{children:["Iterator is an object that has a ",(0,i.jsx)(n.code,{children:"next()"})," method that returns an object with\n",(0,i.jsx)(n.code,{children:"value"})," and ",(0,i.jsx)(n.code,{children:"done"})," properties. The ",(0,i.jsx)(n.code,{children:"value"})," is the next value in the iteration,\nand ",(0,i.jsx)(n.code,{children:"done"})," is a boolean that indicates whether the iteration is done."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:".entries()"}),": iterator that returns an array with the index and value of each\nitem"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:".keys()"}),": iterator that returns the index of each item"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:".values()"}),": iterator that returns the value of each item"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"For example,"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"let a = [\"a\", \"b\", \"c\"];\n\nlet entries = a.entries();\nconsole.log(entries.next()); // { value: [0, 'a'], done: false }\nconsole.log(entries.next()); // { value: [1, 'b'], done: false }\nconsole.log(entries.next()); // { value: [2, 'c'], done: false }\nconsole.log(entries.next()); // { value: undefined, done: true }\n\nlet keys = a.keys();\nconsole.log(keys.next()); // { value: 0, done: false }\nconsole.log(keys.next()); // { value: 1, done: false }\nconsole.log(keys.next()); // { value: 2, done: false }\nconsole.log(keys.next()); // { value: undefined, done: true }\n\nlet values = a.values();\nconsole.log(values.next()); // { value: 'a', done: false }\nconsole.log(values.next()); // { value: 'b', done: false }\nconsole.log(values.next()); // { value: 'c', done: false }\nconsole.log(values.next()); // { value: undefined, done: true }\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Generators on the other hand is a function that returns an iterator. It is\ndefined with an asterisk ",(0,i.jsx)(n.code,{children:"function*"}),". Inside a generator, you can use the\n",(0,i.jsx)(n.code,{children:"yield"})," keyword to return a value for each ",(0,i.jsx)(n.code,{children:"next()"})," call on the iterator. The\nfunction will pause at the ",(0,i.jsx)(n.code,{children:"yield"})," keyword, and resume when the ",(0,i.jsx)(n.code,{children:"next()"})," method\nis called again. It took me a while to understand how it works, but it is a\npowerful tool to create custom iterators. I used generators to implement all 3\nfunctions."]}),"\n",(0,i.jsxs)(n.p,{children:["For example, to implement something that works like ",(0,i.jsx)(n.code,{children:".values()"})," is just:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"function* values(array) {\n  let i = 0;\n  while (i < array.length) {\n    yield array[i++];\n  }\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Generators is a very simple and neat way to create iterators. One tricky thing\nwhen implementing the three iterators is sparse arrays are treated as undefined.\nSo ",(0,i.jsx)(n.code,{children:".keys()"})," will return the index of the empty items, and ",(0,i.jsx)(n.code,{children:".values()"})," will\nreturn ",(0,i.jsx)(n.code,{children:"undefined"})," for the empty items."]}),"\n",(0,i.jsxs)(n.h3,{id:"using-call",children:["Using ",(0,i.jsx)(n.code,{children:".call()"})]}),"\n",(0,i.jsxs)(n.p,{children:["While implementing functions like ",(0,i.jsx)(n.code,{children:".map()"})," that takes a callback function, I\nrealize it also take a second argument that is call ",(0,i.jsx)(n.code,{children:"thisArg"}),". For example,\ngiven a function ",(0,i.jsx)(n.code,{children:"foo"})," used in ",(0,i.jsx)(n.code,{children:"array.map(foo)"}),", if you call ",(0,i.jsx)(n.code,{children:"this"})," in the\ncallback function ",(0,i.jsx)(n.code,{children:"foo"}),", the value of ",(0,i.jsx)(n.code,{children:"this"})," is undefined. And in non-strict\nenvironment ",(0,i.jsx)(n.code,{children:"undefined"})," will be replaced by ",(0,i.jsx)(n.code,{children:"globalThis"}),". You may read more\nabout it in the\n",(0,i.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array#iterative_methods",children:"MDN docs"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["I do not care that much about the correctness of the ",(0,i.jsx)(n.code,{children:"this"})," value here, but at\nleast I do want to know how to specify a ",(0,i.jsx)(n.code,{children:"this"})," value when calling a function. I\ndiscovered three functions provided by the Function object prototype, ",(0,i.jsx)(n.code,{children:".call()"}),",\n",(0,i.jsx)(n.code,{children:".apply()"})," and ",(0,i.jsx)(n.code,{children:".bind()"}),". All functions in JavaScript inherit these three\nmethods. Out of all the tutorial I read, I think W3Schools has the most clear\nand concise explanation you can check:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:".call()"}),": Calls a function with a given ",(0,i.jsx)(n.code,{children:"this"})," value and arguments\n(",(0,i.jsx)(n.a,{href:"https://www.w3schools.com/js/js_function_call.asp",children:"W3Schools"}),")"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:".apply()"}),": Calls a function with a given ",(0,i.jsx)(n.code,{children:"this"})," value and arguments as an\narray (",(0,i.jsx)(n.a,{href:"https://www.w3schools.com/js/js_function_apply.asp",children:"W3Schools"}),")"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:".bind()"}),": Returns a new function with a given ",(0,i.jsx)(n.code,{children:"this"})," value\n(",(0,i.jsx)(n.a,{href:"https://www.w3schools.com/js/js_function_bind.asp",children:"W3Schools"}),")"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["And this is how I make use of ",(0,i.jsx)(n.code,{children:".call()"})," in my implementation:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"// For example .map()\n(array, callback, thisArg) => {\n  let output = [];\n\n  // loop the array\n  let i = 0;\n  while (i < array.length) {\n    // Skip invoke on empty element, but still create empty element\n    if (i in array) {\n      // Using call to specify thisArg\n      // instead of just callback(array[i], i, array)\n      output[output.length] = callback.call(thisArg, array[i], i, array);\n    } else {\n      output.length++;\n    }\n    i++;\n  }\n\n  return output;\n};\n"})}),"\n",(0,i.jsxs)(n.p,{children:["I did not test it and I doubt it actually works because I switched my\nimplementations to be a module with functions rather than methods in a class (I\nwill explain ",(0,i.jsx)(n.a,{href:"#the-setup",children:"below"}),"). The ",(0,i.jsx)(n.code,{children:"this"})," object might not apply in that\ncase. But nevertheless, I learned about ",(0,i.jsx)(n.code,{children:".call()"}),", ",(0,i.jsx)(n.code,{children:".apply()"})," and ",(0,i.jsx)(n.code,{children:".bind()"}),"."]}),"\n",(0,i.jsx)(n.h3,{id:"equality",children:"Equality"}),"\n",(0,i.jsxs)(n.p,{children:['As you might have already known, what is considered "equal" in JavaScript is\ntricky. There are loosely equal (',(0,i.jsx)(n.code,{children:"=="}),") and strictly equal (",(0,i.jsx)(n.code,{children:"==="}),'). In these\nArray functions, there are also subtle differences between some functions when\ntalking about what is "equal" to what. One examples is using ',(0,i.jsx)(n.code,{children:".indexOf()"})," and\n",(0,i.jsx)(n.code,{children:".includes()"})," to find an element in an array."]}),"\n",(0,i.jsxs)(n.p,{children:["There are a few ways to determine if an element is in array. You can use\n",(0,i.jsx)(n.code,{children:".find()"})," or ",(0,i.jsx)(n.code,{children:".findIndex()"})," which takes a callback testing function to determine\nif the element is what you are looking for, which you can control how the\nequality comparison works. But if you do not want to write a callback, you can\nuse ",(0,i.jsx)(n.code,{children:".indexOf()"})," to find an index that equals to the provided value (-1 if not\nfound). Or, you can use ",(0,i.jsx)(n.code,{children:".includes()"})," to check if the array includes the\nprovided value (false if not found). However, there is a subtle difference\nbetween the equality in ",(0,i.jsx)(n.code,{children:".indexOf()"})," and ",(0,i.jsx)(n.code,{children:".includes()"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:".indexOf()"})," uses\n",(0,i.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Strict_equality",children:"strict equal"}),"\n(",(0,i.jsx)(n.code,{children:"==="}),"). Strict equality (",(0,i.jsx)(n.code,{children:"==="}),") is different from equality (",(0,i.jsx)(n.code,{children:"=="}),") where types\nare also checked. Additionally, unlike ",(0,i.jsx)(n.code,{children:"null"})," or ",(0,i.jsx)(n.code,{children:"undefined"}),", ",(0,i.jsx)(n.code,{children:"NaN"})," is not\nstrictly equal to itself. So searching for ",(0,i.jsx)(n.code,{children:"NaN"})," in an array with ",(0,i.jsx)(n.code,{children:".indexOf()"}),"\nwill always be -1. This design where ",(0,i.jsx)(n.code,{children:"NaN"})," is not equal to itself is consistent\nwith a lot of other languages and follows the\n",(0,i.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/NaN#Comparison_with_NaN",children:"IEEE 754 Standard"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"null === null; // true\nundefined === undefined; // true\nNaN === NaN; // false\n\n[NaN].indexOf(NaN); // -1\n"})}),"\n",(0,i.jsxs)(n.p,{children:["However, ",(0,i.jsx)(n.code,{children:".includes()"})," uses\n",(0,i.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness#same-value-zero_equality",children:"same-value-zero equality"}),".\nValues of zero are all considered to be equal, where ",(0,i.jsx)(n.code,{children:"0"})," is equal to ",(0,i.jsx)(n.code,{children:"-0"})," and\n",(0,i.jsx)(n.code,{children:"NaN"})," is also equal to ",(0,i.jsx)(n.code,{children:"NaN"}),". I referenced the implementation of ",(0,i.jsx)(n.code,{children:"sameValueZero"}),"\nfrom the MDN docs linked above."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"sameValueZero(0, 0); // true\nsameValueZero(NaN, NaN); // true\n\n[NaN].includes(NaN); // true\n"})}),"\n",(0,i.jsxs)(n.p,{children:["So if you need to check if there is ",(0,i.jsx)(n.code,{children:"NaN"})," in an array, you should use\n",(0,i.jsx)(n.code,{children:".includes()"})," instead of ",(0,i.jsx)(n.code,{children:".indexOf()"}),". If you want to read more about equality\nin JavaScript,\n",(0,i.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness",children:"this MDN page"}),"\nexplains well with a table listed what is or is not equaled in each way of\nevaluating equality."]}),"\n",(0,i.jsxs)(n.p,{children:["By the way, another subtle difference is ",(0,i.jsx)(n.code,{children:".indexOf()"})," skips empty slots in\nsparse arrays while ",(0,i.jsx)(n.code,{children:".includes()"})," treats empty slots as ",(0,i.jsx)(n.code,{children:"undefined"}),". And all the\n",(0,i.jsx)(n.code,{children:"find..."})," methods like ",(0,i.jsx)(n.code,{children:".find()"})," and ",(0,i.jsx)(n.code,{children:".findIndex()"})," callback function is invoked\nfor every index, unlike rest of the iterative methods like ",(0,i.jsx)(n.code,{children:".map()"})," and\n",(0,i.jsx)(n.code,{children:".forEach()"})," that skips empty slots. Yet another edge cases with sparse arrays."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"[,].indexOf(undefined); // -1\n[,].includes(undefined); // true\n"})}),"\n",(0,i.jsx)(n.h3,{id:"negative-indexes",children:"Negative Indexes"}),"\n",(0,i.jsxs)(n.p,{children:["Some other things I learned included most of the methods that take an index as\ninput supports negative index. For example, you can do ",(0,i.jsx)(n.code,{children:"array.at(-1)"})," to get the\nlast element, but you cannot do ",(0,i.jsx)(n.code,{children:"array[-1]"})," which is equivalent to ",(0,i.jsx)(n.code,{children:'array["-1"]'}),"\n(which most likely is ",(0,i.jsx)(n.code,{children:"undefined"}),")."]}),"\n",(0,i.jsxs)(n.p,{children:["And each function also has special handling for index that is less than\n",(0,i.jsx)(n.code,{children:"-array.length"})," or greater than ",(0,i.jsx)(n.code,{children:"array.length"}),". For example, ",(0,i.jsx)(n.code,{children:".at()"})," returns\n",(0,i.jsx)(n.code,{children:"undefined"})," if the index is outside the range from ",(0,i.jsx)(n.code,{children:"-array.length"})," to\n",(0,i.jsx)(n.code,{children:"array.length - 1"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["There are more complicated examples like ",(0,i.jsx)(n.code,{children:".slice()"}),", which is a function takes a\nstart index and end index and slice the array. If the start index is a negative\nindex, it does the conversion to count from the end of the array. But if that\nstart index is less than ",(0,i.jsx)(n.code,{children:"-array.length"}),", it uses 0 as the start index. And vice\nversa for the end index, if greater than ",(0,i.jsx)(n.code,{children:"array.length"})," it uses ",(0,i.jsx)(n.code,{children:"array.length"}),"\nas the end index. And for these functions that takes two indexes, it also has a\nspecial condition handling the order of the indexes. For ",(0,i.jsx)(n.code,{children:".slice()"}),", if the end\nindex is earlier than the start index after the conversion, it returns an empty\narray. If this sounds confusing, I agree. I suggest read again in point form in\nthe\n",(0,i.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice#parameters",children:"MDN docs"}),"."]}),"\n",(0,i.jsx)(n.h3,{id:"locales",children:"Locales"}),"\n",(0,i.jsxs)(n.p,{children:["I also learned about locale while reading about ",(0,i.jsx)(n.code,{children:".toLocaleString()"}),". It helps\nconvert number, date, letter formats, etc. Probably going too far away from\nArrays, but still, I didn't know JavaScript supports this many variations."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:'[1, 2, 3].toLocaleString("en-US", { style: "currency", currency: "USD" });\n// \'$1.00,$2.00,$3.00\'\n[1, 2, 3].toLocaleString("en-US", { style: "currency", currency: "AUD" });\n// \'A$1.00,A$2.00,A$3.00\'\n[1, 2, 3].toLocaleString("en-US", { style: "currency", currency: "EUR" });\n// \'\u20ac1.00,\u20ac2.00,\u20ac3.00\'\n[1, 2, 3].toLocaleString("en-US", { style: "currency", currency: "JPY" });\n// \'\xa51,\xa52,\xa53\'\n'})}),"\n",(0,i.jsxs)(n.p,{children:["For more you can read, again,\n",(0,i.jsxs)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl",children:["MDN docs on the ",(0,i.jsx)(n.code,{children:"Intl"})," global object"]}),"."]}),"\n",(0,i.jsx)(n.h3,{id:"less-known-functions",children:"Less known functions"}),"\n",(0,i.jsx)(n.p,{children:"There are a few functions that I think are less known. At least I have not used\nthem before and would like to share."}),"\n",(0,i.jsx)(n.h4,{id:"copywithin",children:(0,i.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin",children:(0,i.jsx)(n.code,{children:".copyWithin()"})})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"copyWithin(target, start);\ncopyWithin(target, start, end);\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"It is used to copy elements with in the array by specifying the indexes"}),"\n",(0,i.jsx)(n.li,{children:"It takes three indexes as arguments: target, start and end index"}),"\n",(0,i.jsx)(n.li,{children:"It copies elements within start to end, to the target index"}),"\n",(0,i.jsx)(n.li,{children:"It modifies the array and also return the resulting array"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:'["a", "b", "c", "d", "e"].copyWithin(1, 3);\n// Copy the element at index 3 to index 1\n// ["a", "d", "c", "d", "e"]\n\n["a", "b", "c", "d", "e"].copyWithin(1, 2, 5);\n// Copy the elements index 2-5 to index 1\n// ["a", "c", "d", "e", "e"]\n'})}),"\n",(0,i.jsx)(n.p,{children:"I am not sure when is it useful. I guess when there is something need to\nrearrange elements within an array in such a way."}),"\n",(0,i.jsx)(n.h4,{id:"splice",children:(0,i.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/splice",children:(0,i.jsx)(n.code,{children:".splice()"})})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"splice(start);\nsplice(start, deleteCount);\nsplice(start, deleteCount, ...items);\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"It is used to delete some elements, and insert some new items at where\nelements are deleted"}),"\n",(0,i.jsxs)(n.li,{children:["It is like a combination of ",(0,i.jsx)(n.code,{children:".split()"}),", ",(0,i.jsx)(n.code,{children:".slice()"})," and ",(0,i.jsx)(n.code,{children:".concat()"})]}),"\n",(0,i.jsx)(n.li,{children:"It takes three arguments: starting index, delete count and list of new items"}),"\n",(0,i.jsx)(n.li,{children:"It modifies the array and return the deleted elements"}),"\n",(0,i.jsx)(n.li,{children:"If the delete count is not specified, it deletes till the end"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:'const a = ["a", "b", "c", "d", "e"];\n// Delete starting at index 1 and till the end\nconsole.log(a.splice(1)); // [\'b\', \'c\', \'d\', \'e\']\nconsole.log(a); // [\'a\']\n\nconst b = ["a", "b", "c", "d", "e"];\n// Delete 2 element starting at index 1\nconsole.log(b.splice(1, 2)); // [\'b\', \'c\']\nconsole.log(b); // [\'a\', \'d\', \'e\']\n\nconst c = ["a", "b", "c", "d", "e"];\n// Delete 2 element starting at index 1\n// And insert "m" and "n" in to where elements are deleted\nconsole.log(c.splice(1, 2, "i", "j", "k")); // [\'b\', \'c\']\nconsole.log(c); // [\'a\', \'i\', \'j\', \'k\', \'d\', \'e\']\n'})}),"\n",(0,i.jsx)(n.p,{children:"This is a useful and efficient way to remove or insert items in the middle of\nthe array, despite its functionality is not obvious from the name."}),"\n",(0,i.jsxs)(n.h4,{id:"shift-and-unshift",children:[(0,i.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/shift",children:(0,i.jsx)(n.code,{children:".shift()"})})," and ",(0,i.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/unshift",children:(0,i.jsx)(n.code,{children:".unshift()"})})]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:".shift()"})," is like ",(0,i.jsx)(n.code,{children:".pop()"})," but removes the first element instead of the last\nelement"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:".unshift()"})," is like ",(0,i.jsx)(n.code,{children:".push()"})," but inserts the elements at the beginning of\nthe array"]}),"\n",(0,i.jsxs)(n.li,{children:["I also learned that both ",(0,i.jsx)(n.code,{children:".unshift()"})," and ",(0,i.jsx)(n.code,{children:".push()"})," can take more than 1\nelement"]}),"\n",(0,i.jsxs)(n.li,{children:["And I also learned that both ",(0,i.jsx)(n.code,{children:".unshift()"})," and ",(0,i.jsx)(n.code,{children:".push()"})," returns the new length\nof the array"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"const a = [1, 2, 3, 4, 5];\nconsole.log(a.pop()); // 5\nconsole.log(a); // [1, 2, 3, 4]\n\nconst b = [1, 2, 3, 4, 5];\nconsole.log(b.shift()); // 1\nconsole.log(b); // [2, 3, 4, 5]\n\nconst c = [1, 2, 3, 4, 5];\nconsole.log(c.push(6, 7)); // 7\nconsole.log(c); // [1, 2, 3, 4, 5, 6, 7]\n\nconst d = [1, 2, 3, 4, 5];\nconsole.log(d.unshift(-1, 0)); // 7\nconsole.log(d); // [-1, 0, 1, 2, 3, 4, 5]\n"})}),"\n",(0,i.jsxs)(n.p,{children:["And because how ",(0,i.jsx)(n.a,{href:"#arrays-are-objects",children:"arrays are objects"})," behind the scene,\n",(0,i.jsx)(n.code,{children:".pop()"})," is O(1) but ",(0,i.jsx)(n.code,{children:".shift()"})," is O(n), as explained above."]}),"\n",(0,i.jsxs)(n.h4,{id:"toreversed-tosorted-and-tospliced",children:[(0,i.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/toReversed",children:(0,i.jsx)(n.code,{children:".toReversed()"})}),", ",(0,i.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/toSorted",children:(0,i.jsx)(n.code,{children:".toSorted()"})})," and ",(0,i.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/toSpliced",children:(0,i.jsx)(n.code,{children:".toSpliced()"})})]}),"\n",(0,i.jsxs)(n.p,{children:["There are ",(0,i.jsx)(n.code,{children:".reverse()"}),", ",(0,i.jsx)(n.code,{children:".sort()"}),", and ",(0,i.jsx)(n.code,{children:".splice()"})," that modify the array in\nplace. There are also ",(0,i.jsx)(n.code,{children:".toReversed()"}),", ",(0,i.jsx)(n.code,{children:".toSorted()"})," and ",(0,i.jsx)(n.code,{children:".toSpliced()"})," that are\nfunctionally the same but create a new array instead of modifying the original\none."]}),"\n",(0,i.jsxs)(n.p,{children:["There are also subtle difference in the to... version. These methods never\nproduce sparse array. They convert empty slots into ",(0,i.jsx)(n.code,{children:"undefined"}),", while the\noriginal ",(0,i.jsx)(n.code,{children:".reverse()"}),", ",(0,i.jsx)(n.code,{children:".sort()"})," and ",(0,i.jsx)(n.code,{children:".splice()"})," do not. I really wanted to know\nwhy there is this difference and I went back to the\n",(0,i.jsx)(n.a,{href:"https://github.com/tc39/proposal-change-array-by-copy",children:"original TC39 array by copy proposal"}),".\nIn the end, I found\n",(0,i.jsx)(n.a,{href:"https://github.com/tc39/proposal-change-array-by-copy/issues/8#issuecomment-817763412",children:"this answer"}),".\nIn summary, these functions either are consistent with their counterpart that\ntreats empty slots as empty slots, or be consistent with all other features\nsince ES6 where they do not produce sparse arrays. So either way is breaking\nconsistency, and they decided to stay consistent with the ES6 standard."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"[1, 2, 3, ,].reverse(); // [<empty>, 3, 2, 1]\n[1, 2, 3, ,].toReversed(); // [undefined, 3, 2, 1]\n"})}),"\n",(0,i.jsxs)(n.p,{children:["There are\n",(0,i.jsx)(n.a,{href:"https://github.com/tc39/proposal-change-array-by-copy/issues/101",children:"repeated discussion"}),"\nabout these inconsistencies in the proposal, it's an interesting read. It shows\nhow many problems sparse arrays create for JavaScript language designers."]}),"\n",(0,i.jsx)(n.h4,{id:"with",children:(0,i.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/with",children:(0,i.jsx)(n.code,{children:".with()"})})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"with(index, value)\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:".with()"})," creates a new array with 1 element changed"]}),"\n",(0,i.jsxs)(n.li,{children:["It is like the copying version of the bracket assignment ",(0,i.jsx)(n.code,{children:"array[3] = 'a'"}),"\nnotation"]}),"\n",(0,i.jsxs)(n.li,{children:["It is added as part of the same\n",(0,i.jsx)(n.a,{href:"https://github.com/tc39/proposal-change-array-by-copy",children:"array by copy proposal"}),",\nbut not using the same to... naming pattern, and\n",(0,i.jsx)(n.a,{href:"https://github.com/tc39/proposal-change-array-by-copy/issues/103",children:"people did ask why"})]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"const a = [1, 2, 3];\nconst b = a.with(1, 0);\nconsole.log(a); // [1, 2, 3]\nconsole.log(b); // [1, 0, 3]\n"})}),"\n",(0,i.jsx)(n.h2,{id:"implementation-considerations",children:"Implementation Considerations"}),"\n",(0,i.jsx)(n.p,{children:"So that is mostly the things that I learned while working on this little\nchallenge. If you still find it interesting, here is how I actually did it, and\nhow I test it to ensure at least I have some certainty a majority of the\nfunctionality correct."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.a,{href:"https://github.com/ethanppl/js-array",children:"Here is the link to the repo"})," if you are\ninterested."]}),"\n",(0,i.jsx)(n.h3,{id:"the-setup",children:"The setup"}),"\n",(0,i.jsxs)(n.p,{children:["The major change I made is I wrote an object (",(0,i.jsx)(n.code,{children:"MyArray"}),") that contains functions\nas parameters (e.g. ",(0,i.jsx)(n.code,{children:"MyArray.at(array, 0)"}),"), rather than defining those\nfunctions as methods of an object (e.g. ",(0,i.jsx)(n.code,{children:"array.at(0)"}),"). Therefore, the first\nargument of all the functions is always the input array. With that, I do not\nneed to override the original methods. The built-in Array class is still used to\nconstruct the array, but none of the prototype functions are modified or used."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:'const array = ["a", "b", "c"];\n\n// original function\nconst expected = array.join();\n\n// my function\nconst actual = MyArray.join(array);\n'})}),"\n",(0,i.jsxs)(n.p,{children:["This makes it easier to test too. The ",(0,i.jsx)(n.code,{children:"actual"})," value can be directly compared\nwith the ",(0,i.jsx)(n.code,{children:"expected"})," value."]}),"\n",(0,i.jsxs)(n.p,{children:["For functions that modify the array instance, I can use ",(0,i.jsx)(n.code,{children:"Array.from()"})," to create\ncopies and compare."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:'const array = ["c", "b", "a"];\nconst expected = Array.from(array);\nconst actual = Array.from(array);\n\nexpected.sort();\nMyArray.sort(actual);\n'})}),"\n",(0,i.jsxs)(n.p,{children:["I used ",(0,i.jsx)(n.a,{href:"https://bun.sh/",children:"bun"})," to run and test the code. It is fast, simple to\nuse, support TypeScript, and provide a test runner out of the box."]}),"\n",(0,i.jsxs)(n.p,{children:["In the project, I have to rely on some basic properties of the Array object. I\nneed to get and set the ",(0,i.jsx)(n.code,{children:".length"})," property. As far as I can tell, that is the\nonly way to get the length and manipulate the length. I use angle brackets ",(0,i.jsx)(n.code,{children:"[]"}),"\nto access and assign items in the array. Also, with the ",(0,i.jsx)(n.code,{children:"in"})," and ",(0,i.jsx)(n.code,{children:"delete"}),"\noperator to check if an item exists and remove the items respectively. And last\nbut not least, ",(0,i.jsx)(n.code,{children:"while"})," to loop through the array."]}),"\n",(0,i.jsxs)(n.p,{children:["At first, I thought of using ",(0,i.jsx)(n.code,{children:"Array.reduce"})," to replicate all functionality of\nother functions. It is inspired by functional programming language that a\n",(0,i.jsx)(n.code,{children:"reduce"})," should be able to replicate all operations done recursively on a list.\nBut once I learned about ",(0,i.jsx)(n.a,{href:"#sparse-arrays",children:"sparse arrays"})," and\n",(0,i.jsx)(n.a,{href:"#copy-of-a-reference",children:"copy of a reference"}),", I realize it is near impossible if\nnot actually impossible to do so. So I changed my mind and use a ",(0,i.jsx)(n.code,{children:"while"})," loop\ninstead. Why not ",(0,i.jsx)(n.code,{children:"for"})," loop you may ask? Because then there is ",(0,i.jsx)(n.code,{children:"for ... of"})," loop\nand that is using the iterator behind the scene without the need of an index.\nJust for the implementation to be more simple and raw, I decided to iterate with\nan index instead, using a single keyword, ",(0,i.jsx)(n.code,{children:"while"}),". And thus hopefully a more\ncatchy blog title ",":P"]}),"\n",(0,i.jsx)(n.p,{children:"As I said, most of the implementation are just tedious. They are especially\ntedious when multiple functions share similar functionalities."}),"\n",(0,i.jsx)(n.h3,{id:"similar-functions",children:"Similar functions"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:".find()"}),", ",(0,i.jsx)(n.code,{children:".findIndex()"}),", ",(0,i.jsx)(n.code,{children:".findLast()"}),", and ",(0,i.jsx)(n.code,{children:".findLastIndex()"})," are all very\nsimilar. The difference is only whether it loops from the start or from the end,\nand whether it returns the element or the index once the callback return true."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"{\n  find: <T>(\n    array: Array<T>,\n    callback: (element: T, index: number, array: Array<T>) => boolean,\n    thisArg?: any\n  ) => {\n    let i = 0;\n\n    // loop the array\n    // find does not skip empty value, but behave the same as undefined\n    while (i < array.length) {\n      const result = callback.call(thisArg, array[i], i, array);\n\n      if (result) {\n        return array[i];\n      }\n      i++;\n    }\n\n    return undefined;\n  },\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Once I learned iterators and generators, ",(0,i.jsx)(n.code,{children:".entries()"}),", ",(0,i.jsx)(n.code,{children:".keys()"}),", and\n",(0,i.jsx)(n.code,{children:".values()"})," are very similar. The only difference is the return value."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"{\n  entries: function* entries<T>(array: Array<T>): ArrayIterator<[number, T]> {\n    let i = 0;\n    while (i < array.length) {\n      yield [i, array[i++]];\n    }\n  },\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:".some()"})," and ",(0,i.jsx)(n.code,{children:".every()"})," is like the opposite of each other. They both skip\nempty element in sparse array. And one key thing is they both return early when\n",(0,i.jsx)(n.code,{children:".some()"})," finds true, or ",(0,i.jsx)(n.code,{children:".every()"})," finds false."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"{\n  every: <T>(\n    array: Array<T>,\n    callback: (element: T, index: number, array: Array<T>) => boolean,\n    thisArg?: any\n  ) => {\n    let i = 0;\n    let every = true;\n\n    // loop the array\n    while (i < array.length) {\n      // Skip empty element\n      if (i in array) {\n        const result = callback.call(thisArg, array[i], i, array);\n\n        if (!result) {\n          // If one is false, stop looping\n          every = false;\n          break;\n        }\n      }\n      i++;\n    }\n\n    return every;\n  },\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Despite some differences on what is returned, iterative functions like\n",(0,i.jsx)(n.code,{children:".filter()"}),", ",(0,i.jsx)(n.code,{children:".forEach()"}),", ",(0,i.jsx)(n.code,{children:".map()"}),", ",(0,i.jsx)(n.code,{children:".reduce()"}),", and ",(0,i.jsx)(n.code,{children:".reduceRight()"})," are all\nsimilar. They all skip empty elements in sparse array, and use ",(0,i.jsx)(n.code,{children:"callback.call()"}),"\nto invoke the callback. The only difference is handling the output returned."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"{\n  filter: <T>(\n    array: Array<T>,\n    callback: (element: T, index: number, array: Array<T>) => boolean,\n    thisArg?: any\n  ) => {\n    let i = 0;\n    let output: Array<T> = [];\n\n    // loop the array\n    while (i < array.length) {\n      // Skip empty element\n      if (i in array) {\n        const result = callback.call(thisArg, array[i], i, array);\n\n        if (result) {\n          output[output.length] = array[i];\n        }\n      }\n      i++;\n    }\n\n    return output;\n  },\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["But out of all the functions, I find ",(0,i.jsx)(n.code,{children:".flat()"})," and ",(0,i.jsx)(n.code,{children:".sort()"})," particularly\ninteresting to tackle."]}),"\n",(0,i.jsx)(n.h3,{id:"flat",children:(0,i.jsx)(n.code,{children:".flat()"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:".flat()"})," is interesting because it is a very good application of recursion."]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:".flat()"})," function takes an optional depth argument that defaults to 1,\nspecifying how many layer to flatten recursively."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"{\n  flat: <T>(array: Array<T>, depth: number = 1): Array<T> => {\n    return doFlat([], array, depth);\n  },\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["I first created a ",(0,i.jsx)(n.code,{children:"doFlat"})," helper function that takes 2 arrays and the depth as\nthe arguments. The idea being the first array is the output array, and the\nsecond array is the input array getting flatten, and the depth is the current\ndepth."]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"doFlat"})," function works like this:"]}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Loop through the array"}),"\n",(0,i.jsxs)(n.li,{children:["If the element is an array, and the depth is not 0 yet, recursively call\n",(0,i.jsx)(n.code,{children:"doFlat"})," with the same output array, the current element as the input array,\nand one less depth"]}),"\n",(0,i.jsx)(n.li,{children:"If the element is not an array, push it to the output"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"const doFlat = (output: Array<any>, elements: Array<any>, depth: number) => {\n  let i = 0;\n  while (i < elements.length) {\n    if (i in elements) {\n      if (Array.isArray(elements[i]) && depth > 0) {\n        doFlat(output, elements[i], depth - 1);\n      } else {\n        output[output.length] = elements[i];\n      }\n    }\n    i++;\n  }\n\n  return output;\n};\n"})}),"\n",(0,i.jsxs)(n.p,{children:["If you think of the nested array as trees, this is like a\n",(0,i.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Depth-first_search",children:"depth first search"})," approach.\nFor every array, flatten it until the specified depth, then continue to append\nto the output. I personally find this solution quite simple and elegant."]}),"\n",(0,i.jsx)(n.h3,{id:"sort",children:(0,i.jsx)(n.code,{children:".sort()"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:".sort()"})," sorts the array in place, i.e. it modifies the original array. So,\n",(0,i.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Quicksort",children:"quick sort"})," is a very good algorithm\nfor this. It does not require extra memory space but only swapping elements\nwithin the array."]}),"\n",(0,i.jsxs)(n.p,{children:["The sort function has a default compare function, that is based on the Unicode\norder of the string. So ",(0,i.jsx)(n.code,{children:"7"})," comes before ",(0,i.jsx)(n.code,{children:"80"}),", but ",(0,i.jsx)(n.code,{children:"80"})," actually comes before\n",(0,i.jsx)(n.code,{children:"9"})," by default. This is because when numbers are converted to string, the\nUnicode of ",(0,i.jsx)(n.code,{children:'"80"'})," is earlier than ",(0,i.jsx)(n.code,{children:'"9"'}),". So, I first need to recreate this\ndefault compare function in case the compare function is not specified.\nFortunately, I can reuse the ",(0,i.jsx)(n.code,{children:"String.localeCompare()"})," method."]}),"\n",(0,i.jsxs)(n.p,{children:["Then for sorting, I also used a helper function ",(0,i.jsx)(n.code,{children:"doSort"})," for recursively sorting\nthe array. It takes 4 arguments, the array to sort, the compare function, the\nstarting index and the ending index of range within the array to sort."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"  sort: <T>(array: Array<T>, compareFn?: (a: T, b: T) => number): Array<T> => {\n    if (!compareFn) {\n      compareFn = (a: T, b: T) => {\n        const aStr = `${a}`;\n        const bStr = `${b}`;\n\n        return aStr.localeCompare(bStr);\n      };\n    }\n    doSort(array, compareFn, 0, array.length - 1);\n    return array;\n  },\n"})}),"\n",(0,i.jsxs)(n.p,{children:["If you want to know more about\n",(0,i.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Quicksort",children:"Quick sort"}),", there are plenty\nresources and examples on the Internet. The higher level idea is to pick a pivot\nelement, then partition the current array in to two, with one partition\ncontaining elements lower and the other partition contains elements higher than\nthe pivot. Then recursively do the same algorithm for each of the two\npartitions. The cool thing is this operation can be done without creating extra\narrays, it is only swapping element around within the array, and keep tracking\nthe indexes."]}),"\n",(0,i.jsx)(n.p,{children:"I did not do much optimization, so this is certainly nowhere near the best\nimplementation. The only thing I did is to pick a random pivot. This can lower\nthe chance of the two partitions having a very different size. Partitions that\nare not in similar size may lead to poorer performance because more comparison\nand swapping are needed."}),"\n",(0,i.jsx)(n.p,{children:"Before the algorithm starts, the pivot element is moved to the end of the range.\nThen each of the element in the range is compared to this pivot element. If the\ncompare function return a value smaller than 0, meaning the element is smaller\nthan the pivot, we swap element at the pivot and the current element and\nincrement the pivot index. This brings the current element to the earlier\npartition. Once we finish looping the array, we swap the pivot element (at the\nend of the range) with the pivot index to bring the pivot element in between the\ntwo partitions. Then recursively do the same sort for the two partitions. You\nmay find it easier to understand by watching animations or reading the code\nbelow."}),"\n",(0,i.jsxs)(n.p,{children:["There are also one more tricky thing to handle, briefly mentioned above.\nElements that are ",(0,i.jsx)(n.code,{children:"undefined"})," or empty will not invoke the compare function.\nThey are always sorted to the end of the array, where all ",(0,i.jsx)(n.code,{children:"undefined"})," comes\nfirst, then all empty element at the end. So the first four big ",(0,i.jsx)(n.code,{children:"if"})," in the\n",(0,i.jsx)(n.code,{children:"doSort"})," function is handling ",(0,i.jsx)(n.code,{children:"undefined"})," and empty items. Only when neither of\nthe element being compared nor the pivot element is ",(0,i.jsx)(n.code,{children:"undefined"})," or empty, the\ncompare function is invoked."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"const doSort = <T>(\n  array: Array<T>,\n  compareFn: (a: T, b: T) => number,\n  startIndex: number,\n  endIndex: number\n) => {\n  const length = endIndex - startIndex + 1;\n  if (length <= 1) {\n    return;\n  }\n\n  const randomIndex = Math.floor(Math.random() * length) + startIndex;\n  swap(array, randomIndex, endIndex);\n\n  let currentIndex = startIndex;\n  let pivotIndex = startIndex;\n  while (currentIndex < endIndex) {\n    // pivot is empty, current in front, so swap\n    if (!(endIndex in array)) {\n      swap(array, currentIndex, pivotIndex);\n      pivotIndex++;\n      currentIndex++;\n      continue;\n    }\n\n    // current is empty but pivot is not, do nothing\n    if (!(currentIndex in array)) {\n      currentIndex++;\n      continue;\n    }\n\n    // pivot is undefined but current is defined, current in front, so swap\n    if (array[endIndex] === undefined) {\n      swap(array, currentIndex, pivotIndex);\n      pivotIndex++;\n      currentIndex++;\n      continue;\n    }\n\n    // current is undefined but pivot is not\n    if (array[currentIndex] === undefined || array[endIndex] === undefined) {\n      currentIndex++;\n      continue;\n    }\n\n    // neither are empty or undefined\n    const compare = compareFn(array[currentIndex], array[endIndex]);\n\n    if (compare < 0) {\n      swap(array, currentIndex, pivotIndex);\n      pivotIndex++;\n    }\n\n    currentIndex++;\n  }\n\n  swap(array, pivotIndex, endIndex);\n\n  doSort(array, compareFn, startIndex, pivotIndex - 1);\n  doSort(array, compareFn, pivotIndex + 1, endIndex);\n};\n"})}),"\n",(0,i.jsxs)(n.p,{children:["And the ",(0,i.jsx)(n.code,{children:"swap"})," function is also a helper function I created to swap two elements\nin the array. It has special cases to handle swapping empty items. This ",(0,i.jsx)(n.code,{children:"swap"}),"\nfunction is also used in ",(0,i.jsx)(n.code,{children:".reverse()"})," to reverse the array by swapping elements\nsymmetrically."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"const swap = <T>(array: Array<T>, i: number, j: number) => {\n  if (i === j) {\n    return;\n  }\n\n  const firstTemp = array[i];\n  const isFirstInArray = i in array;\n  const isSecondInArray = j in array;\n\n  if (isSecondInArray) {\n    array[i] = array[j];\n  } else {\n    delete array[i];\n  }\n\n  if (isFirstInArray) {\n    array[j] = firstTemp;\n  } else {\n    delete array[j];\n  }\n\n  return array;\n};\n"})}),"\n",(0,i.jsxs)(n.p,{children:["For the rest, you can check\n",(0,i.jsx)(n.a,{href:"https://github.com/ethanppl/js-array",children:"the repository"})," for the implementation.\nRest of them are mostly simple copying and modifying the length of the array, or\nsome variations of the above. The most complicated one would be ",(0,i.jsx)(n.code,{children:".splice()"}),"\nwhich requires some more thought into copying what are added and deleted and\nmoving the items around in the array."]}),"\n",(0,i.jsx)(n.p,{children:"Just a disclaimer, this is just a fun challenge I set for myself. I am not\nconfident that the implementation is absolutely correct, and I am sure you could\nfind improvements in both time and memory complexity if you wanted to."}),"\n",(0,i.jsx)(n.h2,{id:"final-thoughts",children:"Final thoughts"}),"\n",(0,i.jsx)(n.p,{children:"Despite this exercise being a bit tedious. I think it is worth the effort.\nEspecially with more AI tools and auto-completion, getting to know the\nfundamentals of a language is important. I do not ever think sparse array will\nbe useful, but knowing that it exists and why it exists is helpful."}),"\n",(0,i.jsxs)(n.p,{children:["Building something from scratch, without the help of AI autocompletion, feels\nlike it retrained my brain in designing algorithms and debugging logic errors.\nIt brings me back to the time when I first learn about programming, when\n",(0,i.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Off-by-one_error",children:"off by 1 error"})," and\n",(0,i.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Infinite_loop",children:"infinite loop"})," is the most\nfrequent mistake I make. I enjoyed the iterative process of running and testing\nmy code to validate the algorithms."]}),"\n",(0,i.jsxs)(n.p,{children:["People often say how unreasonable and poorly designed the JavaScript language\nis, which I agree. JavaScript's language design contains inconsistencies, for\nexample, all the edge cases around empty slots and sparse arrays.\nInconsistencies cause surprises, which means code are harder to reason about,\nharder to maintain and debug. However, to me, this exercise provided an\nopportunity for me to experience the inconsistencies. I am not reading about it\nfrom forums or memes. I actually experienced it and I vividly remember how they\nare handled. That is a rewarding thing out of all the tedious ",(0,i.jsx)(n.code,{children:"in"})," checks."]}),"\n",(0,i.jsxs)(n.p,{children:["Other than the inconsistencies, I notice one major theme in JavaScript is the\nlanguage assume the user is correct and avoid throwing errors. Throughout all\nimplementations, there are only 2 cases where it will throw an error. First is\nwhen ",(0,i.jsx)(n.code,{children:".reduce()"})," or ",(0,i.jsx)(n.code,{children:".reduceRight()"})," is called with an empty array plus no\ninitial value given, a ",(0,i.jsx)(n.code,{children:"TypeError"})," is thrown because nothing can be reduced or\nreturned. The second is when ",(0,i.jsx)(n.code,{children:".with()"})," is called with an index that is not\nwithin the ",(0,i.jsx)(n.code,{children:"-array.length"})," to the ",(0,i.jsx)(n.code,{children:"array.length"})," range, a ",(0,i.jsx)(n.code,{children:"RangeError"})," is\nthrown. I think the ",(0,i.jsx)(n.code,{children:".with()"})," function throwing for ",(0,i.jsx)(n.code,{children:"RangeError"})," is a better\ndesign choice compare to other functions that tries to mask the error and just\nreturn a default like an empty array or ",(0,i.jsx)(n.code,{children:"undefined"}),". If something is unexpected,\nlike accessing items outside the range of indexes, clearly the user made a\nmistake. In my opinion, throwing an error is better than letting the program\ncontinues with hard coded default values. I understand the flexibility and\npotential gain in user experience when used in client side applications, but\nthat is just masking the problem and kicking the can down the road."]}),"\n",(0,i.jsx)(n.p,{children:"I hope you learned something new about JavaScript array by reading this. And\nmaybe this inspires you to try something out even if it seems trivial. You might\nlearn something new on the way!"}),"\n",(0,i.jsx)(n.h2,{id:"references",children:"References"}),"\n",(0,i.jsx)(n.h3,{id:"docs",children:"Docs"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array",children:"MDN Docs on Array"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://tc39.es/ecma262/multipage/indexed-collections.html#sec-properties-of-the-array-prototype-object",children:"TC39 Specs on the Array Prototype Object"})}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"time-complexity-of-all-array-functions",children:"Time complexity of all Array functions"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.em,{children:"Maybe this is useful in the future, while I still remembers"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"n"})," denote the length of the original array"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"k"})," usually denote the input array length"]}),"\n"]}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Functions"}),(0,i.jsx)(n.th,{children:"Time Complexity"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"at"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"O(1)"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"concat"}),(0,i.jsxs)(n.td,{children:[(0,i.jsx)(n.code,{children:"O(n)"})," where n being the length of the second array"]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"copyWithin"}),(0,i.jsxs)(n.td,{children:[(0,i.jsx)(n.code,{children:"O(n)"})," or less where n being the number of items to copy"]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"entries"}),(0,i.jsxs)(n.td,{children:[(0,i.jsx)(n.code,{children:"O(1)"})," where each iteration is ",(0,i.jsx)(n.code,{children:"O(1)"})]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"every"}),(0,i.jsxs)(n.td,{children:[(0,i.jsx)(n.code,{children:"O(n)"})," or less"]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"fill"}),(0,i.jsxs)(n.td,{children:[(0,i.jsx)(n.code,{children:"O(n)"})," or less"]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"filter"}),(0,i.jsxs)(n.td,{children:[(0,i.jsx)(n.code,{children:"O(n)"})," if callback is ",(0,i.jsx)(n.code,{children:"O(1)"})]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"find"}),(0,i.jsxs)(n.td,{children:[(0,i.jsx)(n.code,{children:"O(n)"})," if callback is ",(0,i.jsx)(n.code,{children:"O(1)"})]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"findIndex"}),(0,i.jsxs)(n.td,{children:[(0,i.jsx)(n.code,{children:"O(n)"})," if callback is ",(0,i.jsx)(n.code,{children:"O(1)"})]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"findLast"}),(0,i.jsxs)(n.td,{children:[(0,i.jsx)(n.code,{children:"O(n)"})," if callback is ",(0,i.jsx)(n.code,{children:"O(1)"})]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"findLastIndex"}),(0,i.jsxs)(n.td,{children:[(0,i.jsx)(n.code,{children:"O(n)"})," if callback is ",(0,i.jsx)(n.code,{children:"O(1)"})]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"flat"}),(0,i.jsxs)(n.td,{children:[(0,i.jsx)(n.code,{children:"O(n ^ d)"})," in the worst case where d is the depth"]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"flatMap"}),(0,i.jsxs)(n.td,{children:[(0,i.jsx)(n.code,{children:"O(n)"})," if callback is ",(0,i.jsx)(n.code,{children:"O(1)"})]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"forEach"}),(0,i.jsxs)(n.td,{children:[(0,i.jsx)(n.code,{children:"O(n)"})," if callback is ",(0,i.jsx)(n.code,{children:"O(1)"})]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"includes"}),(0,i.jsxs)(n.td,{children:[(0,i.jsx)(n.code,{children:"O(n)"})," or less"]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"indexOf"}),(0,i.jsxs)(n.td,{children:[(0,i.jsx)(n.code,{children:"O(n)"})," or less"]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"join"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"O(n)"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"keys"}),(0,i.jsxs)(n.td,{children:[(0,i.jsx)(n.code,{children:"O(1)"})," where each iteration is ",(0,i.jsx)(n.code,{children:"O(1)"})]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"lastIndexOf"}),(0,i.jsxs)(n.td,{children:[(0,i.jsx)(n.code,{children:"O(n)"})," or less"]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"map"}),(0,i.jsxs)(n.td,{children:[(0,i.jsx)(n.code,{children:"O(n)"})," if callback is ",(0,i.jsx)(n.code,{children:"O(1)"})]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"pop"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"O(1)"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"push"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"O(k)"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"reduce"}),(0,i.jsxs)(n.td,{children:[(0,i.jsx)(n.code,{children:"O(n)"})," if callback is ",(0,i.jsx)(n.code,{children:"O(1)"})]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"reduceRight"}),(0,i.jsxs)(n.td,{children:[(0,i.jsx)(n.code,{children:"O(n)"})," if callback is ",(0,i.jsx)(n.code,{children:"O(1)"})]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"reverse"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"O(n)"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"shift"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"O(n)"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"slice"}),(0,i.jsxs)(n.td,{children:[(0,i.jsx)(n.code,{children:"O(n)"})," or less"]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"some"}),(0,i.jsxs)(n.td,{children:[(0,i.jsx)(n.code,{children:"O(n)"})," or less"]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"sort"}),(0,i.jsxs)(n.td,{children:[(0,i.jsx)(n.code,{children:"O(n log n)"})," on average"]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"splice"}),(0,i.jsxs)(n.td,{children:[(0,i.jsx)(n.code,{children:"O(n + k)"})," or less"]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"toLocaleString"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"O(n)"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"toReversed"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"O(n)"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"toSorted"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"O(n log n)"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"toSpliced"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"O(n + k)"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"toString"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"O(n)"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"unshift"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"O(n + k)"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"values"}),(0,i.jsxs)(n.td,{children:[(0,i.jsx)(n.code,{children:"O(1)"})," where each iteration is ",(0,i.jsx)(n.code,{children:"O(1)"})]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"with"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"O(1)"})})]})]})]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["For ",(0,i.jsx)(n.code,{children:"flat"}),", that is just the absolute worse case scenario where n is the\naverage length of every array exists, while each array contains n number of\narrays within, like an exponential tree"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"push"}),", ",(0,i.jsx)(n.code,{children:"splice"}),", ",(0,i.jsx)(n.code,{children:"toSpliced"})," and ",(0,i.jsx)(n.code,{children:"unshift"})," depend on the input size ",(0,i.jsx)(n.code,{children:"k"})," of\nthe elements to be added to the array"]}),"\n",(0,i.jsxs)(n.li,{children:["For ",(0,i.jsx)(n.code,{children:"toLocaleString"})," and ",(0,i.jsx)(n.code,{children:"toString"}),", I am not sure, but I assume the same as\n",(0,i.jsx)(n.code,{children:"join"})," where it accesses each element and concatenate to a string, so O(n)"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>o});var r=t(6540);const i={},s=r.createContext(i);function a(e){const n=r.useContext(s);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),r.createElement(s.Provider,{value:n},e.children)}},190:e=>{e.exports=JSON.parse('{"permalink":"/blog/2025/02/23/js-array","source":"@site/blog/2025-02-23-js-array.md","title":"Reimplement all JavaScript Array Functions with while loops only","description":"Last month, out of curiosity, I reimplemented all 38 JavaScript Array functions","date":"2025-02-23T00:00:00.000Z","tags":[{"inline":true,"label":"Computers","permalink":"/blog/tags/computers"},{"inline":true,"label":"JavaScript","permalink":"/blog/tags/javascript"}],"readingTime":32.28,"hasTruncateMarker":true,"authors":[{"name":"Ethan Pang","url":"https://ethanppl.com/","imageURL":"https://github.com/ethanppl.png","key":"ethan","page":null}],"frontMatter":{"title":"Reimplement all JavaScript Array Functions with while loops only","tags":[{"label":"Computers","permalink":"computers"},{"label":"JavaScript","permalink":"javascript"}],"toc_min_heading_level":2,"toc_max_heading_level":3,"authors":"ethan"},"unlisted":false,"prevItem":{"title":"My $4/month self-hosted web server setup","permalink":"/blog/2025/05/25/self-host"},"nextItem":{"title":"How does the 6 digits number in multifactor authentication works?","permalink":"/blog/2024/12/28/mfa-totp"}}')}}]);