"use strict";(self.webpackChunkmy_wiki=self.webpackChunkmy_wiki||[]).push([[8024],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>h});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var o=a.createContext({}),m=function(e){var t=a.useContext(o),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},p=function(e){var t=m(e.components);return a.createElement(o.Provider,{value:t},e.children)},u="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,o=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),u=m(n),d=i,h=u["".concat(o,".").concat(d)]||u[d]||c[d]||r;return n?a.createElement(h,l(l({ref:t},p),{},{components:n})):a.createElement(h,l({ref:t},p))}));function h(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,l=new Array(r);l[0]=d;var s={};for(var o in t)hasOwnProperty.call(t,o)&&(s[o]=t[o]);s.originalType=e,s[u]="string"==typeof e?e:i,l[1]=s;for(var m=2;m<r;m++)l[m]=n[m];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},4346:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>o,contentTitle:()=>l,default:()=>c,frontMatter:()=>r,metadata:()=>s,toc:()=>m});var a=n(7462),i=(n(7294),n(3905));const r={},l="The Elm Architecture",s={unversionedId:"computers/programming/software-design/elm",id:"computers/programming/software-design/elm",title:"The Elm Architecture",description:"Explaining good software design with Elm.",source:"@site/docs/computers/programming/software-design/elm.md",sourceDirName:"computers/programming/software-design",slug:"/computers/programming/software-design/elm",permalink:"/wiki/computers/programming/software-design/elm",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Software Design",permalink:"/wiki/computers/programming/software-design/"},next:{title:"Real World Examples",permalink:"/wiki/computers/programming/software-design/real-world"}},o={},m=[{value:"Links",id:"links",level:2}],p={toc:m},u="wrapper";function c(e){let{components:t,...n}=e;return(0,i.kt)(u,(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"the-elm-architecture"},"The Elm Architecture"),(0,i.kt)("p",null,"Explaining good software design with Elm."),(0,i.kt)("h2",{id:"links"},"Links"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("a",{parentName:"p",href:"https://youtu.be/PLFl95c-IiU"},"Domain Modeling Made Functional | Scott Wlaschin")),(0,i.kt)("details",null,(0,i.kt)("summary",null,"Notes"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"How can this be improved?"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-elm",metastring:"showLineNumbers",showLineNumbers:!0},"type Contact = {\n  FirstName: string\n  MiddleInitial: string\n  LastName: string\n\n  EmailAddress: string\n  IsEmailVerified: bool\n  }\n"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"A data structure that represents design choice:"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-elm",metastring:"showLineNumbers",showLineNumbers:!0},"type String50 = String 50 of string\n\nlet createString50 (s: string) =\n  if s.Length <= 50\n    then Some (String50 s)\n    else None\n\ncreateString50:\n  string -> String50 option\n")),(0,i.kt)("p",{parentName:"li"},"or:"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-elm",metastring:"showLineNumbers",showLineNumbers:!0},'let createEmailAddress (s: string) =\n  if s.Contains "@"\n    then Some (EmailAddress s)\n    else None\n\ncreateEmailAddress:\n  string -> EmailAddress option\n'))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Union types:"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-elm",metastring:"showLineNumbers",showLineNumbers:!0},"type VerifiedEmail = VerifiedEmail of EmailAddress\ntype VertificationService =\n  (EmailAddress * Verificationhash) -> VerifiedEmail option\n\ntype EmailContactInfo =\n  | Unverified of EmailAddress\n  | Verified of EmailAddress\n"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"A data structure that represents a business rule:"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-elm",metastring:"showLineNumbers",showLineNumbers:!0},"type Contact = {\n  Name: PersonalName\n  Email: EmailContactInfo\n  }\n\ntype PersonalName = {\n  FirstName: String50\n  MiddleInitial: String50 option\n  LastName: String50\n  }\n")))))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("a",{parentName:"p",href:"https://youtu.be/IcgmSRJHu_8"},"Make Impossible States Impossible | Richard Feldman")),(0,i.kt)("details",null,(0,i.kt)("summary",null,"Notes"),(0,i.kt)("p",{parentName:"li"},"Make impossible states impossible"),(0,i.kt)("details",null,(0,i.kt)("summary",null,"We need to restore a recently deleted input"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Bad design:"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-elm",metastring:"showLineNumbers",showLineNumbers:!0},"type Model =\n  { status: Maybe String\n  , questionToRestore: Maybe SurveyQuestion}\n"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Happy path:"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-elm",metastring:"showLineNumbers",showLineNumbers:!0},'{ status = Just "Question deleted"\n, questionToRestore = Just someQuestion\n}\n\n{ status = Nothing\n, questionToRestore = Nothing\n}\n'))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Impossible path but possible in code:"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-elm",metastring:"showLineNumbers",showLineNumbers:!0},'{ status = Nothing\n, questionToRestore = Just someQuestion\n}\n\n{ status = Just "Question deleted"\n, questionToRestore = Nothing\n}\n'))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Proper solution: union types"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-elm",metastring:"showLineNumbers",showLineNumbers:!0},"type Status\n  = NoStatus\n  | DeletedStatus String Question\n"))))),(0,i.kt)("details",null,(0,i.kt)("summary",null,"Zip list: maintaining a history (go back, current, next)"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Bad design:"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-elm",metastring:"showLineNumbers",showLineNumbers:!0},"type History =\n  { questions: List Question\n  , current: Question\n  }\n"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Happy path:"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-elm",metastring:"showLineNumbers",showLineNumbers:!0},"{ questions = [q1, q2, q3]\n, current = q2\n}\n"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Impossible path but possible in code:"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-elm",metastring:"showLineNumbers",showLineNumbers:!0},"{ questions = []\n, current = q1\n}\n"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Better solution: zip list, two lists with 1 element. Impossible to have a\nnon-existing element."),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-elm",metastring:"showLineNumbers",showLineNumbers:!0},"type History =\n  { previous: List Question\n  , current: Question\n  , remaining: List Question\n  }\n\n-- example\n{ previous: [q1, q2]\n, current: q3\n, remaining: [q4, q5]\n}\n"))))),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"No break changes:",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Implement a zip list internally in a module and expose an interface for\nother modules"),(0,i.kt)("li",{parentName:"ul"},"Other modules can only interact with back and forward functions"),(0,i.kt)("li",{parentName:"ul"},"The internal implementation can change without breaking the interface")))))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("a",{parentName:"p",href:"https://youtu.be/jl1tGiUiTtI"},"Convergent Evolution | Evan Czaplicki")),(0,i.kt)("details",null,(0,i.kt)("summary",null,"Notes"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Convergent Evolution: people working independently converge to similar\nsolutions without prior knowledge of each other",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Flying seems a neat idea, so bees and birds both have wings"),(0,i.kt)("li",{parentName:"ul"},'But bees and birds have very different "implementation details"'),(0,i.kt)("li",{parentName:"ul"},'The key is not to determine which one "implemented" flying better but to\nconsider how the design of wings fit into other "features" of the design'))),(0,i.kt)("li",{parentName:"ul"},"In Elm and React, both similarly have virtual DOM but implemented and look\nvery differently"),(0,i.kt)("li",{parentName:"ul"},"JavaScript has C-style syntax while Elm has ML-style syntax doesn't matter.\nThe thing is how well this decision fit with other features. ML-style syntax\nfits well with Elm emphasizing the immutability feature."),(0,i.kt)("li",{parentName:"ul"},"Elm architecture vs Flux in React:",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Elm architecture: Model passes HTML to runtime, runtime passes messages\nback to the model, then loops"),(0,i.kt)("li",{parentName:"ul"},"Both reached an MVC pattern, following a uni-directional flow"))),(0,i.kt)("li",{parentName:"ul"},"Other properties:",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Immutability: ",(0,i.kt)("inlineCode",{parentName:"li"},"lazy")," in Elm"),(0,i.kt)("li",{parentName:"ul"},"Static analysis: linter or TypeScript in React, hint messages at compile\ntime in Elm"))),(0,i.kt)("li",{parentName:"ul"},"It's not right or wrong choosing which stack, the key is how the feature\nsets work together"),(0,i.kt)("li",{parentName:"ul"},"The overlapping ideas of these stacks, despite being implemented\ndifferently, are the ones that seem to be good ideas")))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("a",{parentName:"p",href:"https://youtu.be/XpDsk374LDE"},"The Life of a File | Evan Czaplicki")),(0,i.kt)("details",null,(0,i.kt)("summary",null,"Notes"),(0,i.kt)("p",{parentName:"li"},'How does he grow Elm code? What happens when the file is "too long"?'),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Life of a file: start small and grow, eventually how a file grow until it\nsplits into two files"),(0,i.kt)("li",{parentName:"ul"},"JavaScript knowledge:",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Prefer shorter files: seems like shorter is better because it avoids\nsneaky mutations when files get larger"),(0,i.kt)("li",{parentName:"ul"},"Get the architecture right from the start: refactoring is very risky and a\nfull rewrite is easier"))),(0,i.kt)("li",{parentName:"ul"},"Elm perspective:",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"It is not possible to share variables and states, sneaky mutation is 0%"),(0,i.kt)("li",{parentName:"ul"},"Refactoring is cheap and reliable with static types and static analysis"),(0,i.kt)("li",{parentName:"ul"},"The way Elm is designed changes how you grow a file or even the codebase")))),(0,i.kt)("br",null),"The idea is to build modules around data structures, not the length of the file.",(0,i.kt)("br",null),(0,i.kt)("br",null),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Things to consider when choosing the data structures:",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Static type analysis? (spelling of keys should be checked)"),(0,i.kt)("li",{parentName:"ul"},"Does ordering matter? (objects or lists)"),(0,i.kt)("li",{parentName:"ul"},"Union types to limit the possible states or require the ability to\ndynamically update the list of possibilities?"))),(0,i.kt)("li",{parentName:"ul"},"Breakout functions into modules when they start to build around data\nstructure or specific functionalities for a domain in the business model:",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"And within a module, the implementation details (the data structure)\nshould not leak"),(0,i.kt)("li",{parentName:"ul"},"Only expose a limited interface, but no less"),(0,i.kt)("li",{parentName:"ul"},"Feature changes are to extend/limit the interface the module exposes"),(0,i.kt)("li",{parentName:"ul"},"Testing on the API, rather than every usage"),(0,i.kt)("li",{parentName:"ul"},"Refactoring within the module is easier because the API won\u2019t change"),(0,i.kt)("li",{parentName:"ul"},"Modules can also maintain invariant (e.g. only two fruits), rules that\ncannot be enforced through data structure only"))),(0,i.kt)("li",{parentName:"ul"},"Bad practices",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Get/set: the purpose of modules is to hide details, but setters will\nexpose details. Instead, try to expose as little as possible but no less"),(0,i.kt)("li",{parentName:"ul"},"Don\u2019t overdo it: only extract modules when there is a problem. Don\u2019t do\npremature refactoring."),(0,i.kt)("li",{parentName:"ul"},"Don\u2019t try to make modules because something is similar, focus on the data\nstructure. Only do it when things are related."))))))))}c.isMDXComponent=!0}}]);